<?php

namespace KirkwoodSkeleton\Connections;

use PDO;

class PDOConnection
{

  /** @var \PDO */
  protected $db;
  protected $dbName;

  protected static $connections = [];

  public static function getConnection($connectionName)
  {
    if (!isset(static::getDatabaseConnections()[$connectionName])) {
      error_log("$connectionName not found in Database Connections");
      die();
    }

    if (array_key_exists($connectionName, static::$connections)) {
      return static::$connections[$connectionName];
    }

    $data = static::getDatabaseConnections()[$connectionName];
    $connection = new PDOConnection($data["fileName"], $data["pdoName"], $data["dbName"]);
    static::$connections[$connectionName] = $connection;

    return $connection;
  }

  /**
   * @return array The returned array should be associative where each key is a unique name (identifier) for the
   *    connection and the value is also an associative array with the following three keys:
   *    "fileName" should be the (absolute) path to the PDO connection file on the server
   *    "pdoName" should be the name of the PDO variable generated by that file (e.g., session_pdo)
   *    "dbName" is the name of the database accessed via that connection (for use with SQLServer connections, this name
   *        will be used when executing stored procedures. E.g., [dbName].[dbo].[spName]
   */
  protected static function getDatabaseConnections()
  {
    return [];
  }

  protected function __construct($connectionFile, $expectedPDOVariable, $dbName)
  {
    require $connectionFile;

    $this->db = &$$expectedPDOVariable;

    if (!isset($this->db)) {
      error_log("Unable to create database connection. Check the connection file string and expected pdo variable name. Given pdo variable name is: $expectedPDOVariable");
      die();
    }

    if (!isset($dbName)) {
      error_log("Unable to create database connection. No database name provided.");
      die();
    }
    $this->dbName = $dbName;
  }

  public function prepare($string)
  {
    return $this->db->prepare($string);
  }

  public function prepareSP($spName, $csParams = "")
  {
    $stmt = $this->db->prepare("EXEC [{$this->dbName}].[dbo].[$spName] " . $csParams);
    return $stmt;
  }

  public function executeSP($spName, array $params = [])
  {
    $csParams = implode(", ", array_map(function ($x) {
      return ":$x";
    }, array_keys($params)));
    $stmt = $this->prepareSP($spName, $csParams);

    try {
      $stmt->execute($params);
      return $stmt;
    } catch (\Exception $e) {
      error_log("Execution error caught!");
      error_log($e->getMessage());
      error_log($e->getTraceAsString());
      die();
    }
  }

  protected function sanitizeArray(array $arr)
  {
    $temp = [];
    foreach ($arr as $key => $value) {
      $temp[$key] = htmlspecialchars($value);
    }

    return $temp;
  }

  protected function sanitize2DArray(array $arr)
  {
    $temp = [];
    foreach ($arr as $subArr) {
      $temp[] = $this->sanitizeArray($subArr);
    }
    return $temp;
  }

  public function fetchOneSP($spName, array $params = [], $sanitizeOutput = true)
  {
    $stmt = $this->executeSP($spName, $params);
    $ret = $stmt->fetch(PDO::FETCH_ASSOC);
    $stmt->closeCursor();

    return $sanitizeOutput ? $this->sanitizeArray($ret) : $ret;
  }

  public function fetchAllSP($spName, array $params = [], $sanitizeOutput = true)
  {
    $stmt = $this->executeSP($spName, $params);
    $ret = $stmt->fetchAll(PDO::FETCH_ASSOC);
    $stmt->closeCursor();
    return $sanitizeOutput ? $this->sanitize2DArray($ret) : $ret;
  }

  public function execute($string, array $params = [])
  {
    $csParams = implode(", ", array_map(function ($x) {
      return ":$x";
    }, array_keys($params)));
    $stmt = $this->prepare($string . " " . $csParams);

    try {
      $stmt->execute($params);
      return $stmt;
    } catch (\Exception $e) {
      error_log("Execution error caught!");
      error_log($e->getMessage());
      error_log($e->getTraceAsString());
      die();
    }
  }

  public function fetchAll($string, array $params = [], $sanitizeOutput = true)
  {
    $stmt = $this->execute($string, $params);
    $ret = $stmt->fetchAll(PDO::FETCH_ASSOC);
    $stmt->closeCursor();
    return $sanitizeOutput ? $this->sanitize2DArray($ret) : $ret;
  }

}